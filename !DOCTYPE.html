<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dino Runner ‚Äî Way Lower Gravity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    :root {
      --bg: #f6f7fb;
      --panel: #ffffff;
      --ink: #202533;
      --muted: #6b7280;
      --accent: #0ea5e9;
      --border: #d7dbe6;
      --success: #16a34a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 20px;
    }
    .sidebar {
      width: 240px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      height: fit-content;
      box-shadow: 0 1px 3px rgba(16,24,40,.04);
      position: sticky;
      top: 20px;
    }
    .sidebar h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      display: flex; align-items: center; gap: 8px;
    }
    .board {
      list-style: none;
      padding: 0;
      margin: 0;
      border-top: 1px dashed var(--border);
    }
    .board li {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px dashed var(--border);
      font-variant-numeric: tabular-nums;
    }
    .board li i {
      color: var(--muted);
      font-style: normal;
      width: 1.8em;
    }

    .gamewrap {
      display: grid;
      gap: 10px;
      justify-items: center;
    }
    .hud {
      width: 860px;
      max-width: 92vw;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      color: var(--ink);
    }
    .hud .left, .hud .right {
      display: flex; gap: 14px; align-items: center;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 999px;
      font-weight: 600;
      box-shadow: 0 1px 2px rgba(16,24,40,.04);
    }
    .tag b { color: var(--ink); }
    .tag i { color: var(--muted); font-style: normal; }

    .stage {
      position: relative;
      width: 860px;
      max-width: 92vw;
      background: linear-gradient(#ffffff, #f3f5fa 75%);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 24px rgba(16,24,40,.06);
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .card {
      pointer-events: none;
      background: rgba(255,255,255,.9);
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      text-align: center;
      color: var(--ink);
      box-shadow: 0 8px 24px rgba(2,6,23,.08);
    }
    .card .title { font-weight: 700; }
    .card .sub { color: var(--muted); margin-top: 4px; }

    .legend {
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <h3>üèÜ Leaderboard</h3>
    <ol id="board" class="board"></ol>
    <div class="legend" style="margin-top:8px;">
      Top 5 saved locally. Plug in an API to go global.
    </div>
  </aside>

  <main class="gamewrap">
    <div class="hud">
      <div class="left">
        <span class="tag">Score: <b id="score">0</b></span>
        <span class="tag">Best: <b id="best">0</b></span>
        <span class="tag">Speed: <b id="speed">0</b><i>px/f</i></span>
      </div>
      <div class="right legend">Jump: Space/Click ¬∑ Restart: R</div>
    </div>

    <div class="stage">
      <canvas id="game" width="840" height="240" aria-label="Dino Runner"></canvas>
      <div id="overlay" class="overlay">
        <div class="card">
          <div class="title" id="ovlTitle">Tap or press Space to start</div>
          <div class="sub" id="ovlSub">Spin like a GD cube. Avoid cacti and birds. Good luck.</div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // ===== DOM refs =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    const speedEl = document.getElementById('speed');
    const boardEl = document.getElementById('board');
    const overlay = document.getElementById('overlay');
    const ovlTitle = document.getElementById('ovlTitle');
    const ovlSub = document.getElementById('ovlSub');

    // ===== Storage keys =====
    const LS_BEST = 'dino.best.v2';
    const LS_BOARD = 'dino.board.v2';

    // ===== Game constants (tuning) =====
    const GROUND_Y = canvas.height - 16; // ground line
    const gravity = 0.45;                // WAY lower gravity (floatier)
    const jumpPower = 12;                // jump velocity (kept same)
    let speed = 30;                     // faster starting speed
    const spawnCooldown = 1200;          // ms between hazards
    const maxTimeWithoutCactus = 1500;   // force cactus after this
    const cactusSpacing = 10;            // spacing inside bursts

    // ===== State =====
    let started = false;
    let gameOver = false;
    let deathLock = false;
    let score = 0;
    let best = Number(localStorage.getItem(LS_BEST) || 0);
    let lastTime = performance.now();
    let lastSpawnTime = 0;
    let lastCactusTime = 0;
    let rotation = 0; // radians

    // ===== Entities =====
    const dino = {
      x: 60,
      y: GROUND_Y - 40,
      vy: 0,
      size: 40,
      dead: false,
      jump() {
        if (this.dead) return;
        const onGround = this.y >= GROUND_Y - this.size;
        if (!onGround) return;
        this.vy = -jumpPower;
        rotation = 0;
      },
      update(dt) {
        this.y += this.vy;
        this.vy += gravity;
        // ground collide
        if (this.y > GROUND_Y - this.size) {
          this.y = GROUND_Y - this.size;
          this.vy = 0;
          rotation = 0;
        } else {
          // spin in air: full spin every 0.5s
          rotation += (Math.PI * 2) * (dt / 500);
        }
      },
      draw() {
        ctx.save();
        ctx.translate(this.x + this.size/2, this.y + this.size/2);
        ctx.rotate(rotation);
        drawDinoSprite(-this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
      }
    };

    /** Simple procedural dino sprite drawn in code (no external assets) */
    function drawDinoSprite(x, y, w, h) {
      const body = '#1fbf5b';
      const shade = '#129247';
      const eye = '#0b0f1a';
      const unit = Math.min(w, h) / 10;

      // body block
      ctx.fillStyle = body;
      roundRect(x, y + unit*2, w - unit*1.2, h - unit*2.4, unit*1.2, true, false);
      // head
      roundRect(x + w - unit*5, y + unit, unit*4.2, unit*4, unit, true, false);
      // jaw
      roundRect(x + w - unit*5, y + unit*4, unit*3, unit*1.8, unit*0.8, true, false);
      // tail
      roundRect(x + unit*0.2, y + unit*4, unit*2.4, unit*1.4, unit*0.7, true, false);
      // legs
      ctx.fillStyle = shade;
      ctx.fillRect(x + unit*3.2, y + h - unit*2.2, unit*1.4, unit*2.2);
      ctx.fillRect(x + unit*6.2, y + h - unit*2.2, unit*1.4, unit*2.2);
      // eye
      ctx.fillStyle = eye;
      ctx.fillRect(x + w - unit*2.4, y + unit*2, unit*0.9, unit*0.9);
    }

    function roundRect(x, y, w, h, r, fill = true, stroke = false) {
      const r2 = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + r2, y);
      ctx.arcTo(x + w, y, x + w, y + h, r2);
      ctx.arcTo(x + w, y + h, x, y + h, r2);
      ctx.arcTo(x, y + h, x, y, r2);
      ctx.arcTo(x, y, x + w, y, r2);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    /** Hazard arrays */
    let obstacles = []; // cacti
    let birds = [];

    function spawnObstacleBurst() {
      const count = Math.floor(Math.random() * 3) + 1; // 1..3
      for (let i = 0; i < count; i++) {
        obstacles.push({
          x: canvas.width + i * cactusSpacing,
          w: 22,
          h: 44
        });
      }
      lastCactusTime = performance.now();
    }

    function spawnBird() {
      birds.push({
        x: canvas.width,
        y: Math.random() * 90 + 30, // mid-air lanes
        s: 28,                       // size
        t: 0                         // flap timer
      });
    }

    function maybeSpawnHazard(t) {
      if (t - lastSpawnTime < spawnCooldown) return;
      // force cactus if too long
      if (t - lastCactusTime >= maxTimeWithoutCactus) {
        spawnObstacleBurst(); lastSpawnTime = t; return;
      }
      // 55% cactus, 45% bird
      (Math.random() < 0.55) ? spawnObstacleBurst() : spawnBird();
      lastSpawnTime = t;
    }

    // ===== Persistence (leaderboard) =====
    function saveLeaderboardScore(s) {
      let arr = JSON.parse(localStorage.getItem(LS_BOARD) || '[]');
      arr.push(s);
      arr = arr.sort((a,b)=>b-a).slice(0,5);
      localStorage.setItem(LS_BOARD, JSON.stringify(arr));
    }
    function getLeaderboard() {
      return JSON.parse(localStorage.getItem(LS_BOARD) || '[]');
    }
    function renderBoard() {
      const arr = getLeaderboard();
      if (!arr.length) {
        boardEl.innerHTML = '<li><i>#1</i><span>No scores yet</span><span>0</span></li>';
        return;
      }
      boardEl.innerHTML = arr.map((v,i)=>(
        `<li><i>#${i+1}</i><span>Run</span><span>${v}</span></li>`
      )).join('');
    }

    // ===== Game control =====
    function showOverlay(title, sub) {
      ovlTitle.textContent = title;
      ovlSub.textContent = sub || '';
      overlay.style.display = 'grid';
    }
    function hideOverlay() {
      overlay.style.display = 'none';
    }

    function handleDeath() {
      if (gameOver) return;
      gameOver = true;
      deathLock = true;
      setTimeout(()=>deathLock=false, 400);
      dino.dead = true;
      best = Math.max(best, Math.floor(score));
      localStorage.setItem(LS_BEST, String(best));
      bestEl.textContent = best;
      saveLeaderboardScore(Math.floor(score));
      renderBoard();
      started = false;
      showOverlay('Game Over ‚Äî press R to restart', `Score: ${Math.floor(score)} ¬∑ Best: ${best}`);
    }

    function restart() {
      obstacles = [];
      birds = [];
      score = 0;
      dino.y = GROUND_Y - dino.size;
      dino.vy = 0;
      dino.dead = false;
      gameOver = false;
      started = true;
      lastCactusTime = performance.now();
      hideOverlay();
    }

    // ===== Input =====
    document.addEventListener('keydown', (e) => {
      if (['Space','ArrowUp','KeyR'].includes(e.code)) e.preventDefault();
      if (deathLock) return;
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        if (gameOver) restart();
        else { started = true; hideOverlay(); dino.jump(); }
      }
      if (e.code === 'KeyR' && gameOver) restart();
    });
    canvas.addEventListener('pointerdown', () => {
      if (deathLock) return;
      if (gameOver) restart();
      else { started = true; hideOverlay(); dino.jump(); }
    });

    // ===== Update & Render =====
    function update(dt, t) {
      if (!started || gameOver) return;

      // move/physics
      dino.update(dt);

      // score and UI
      score += dt * 0.02;
      scoreEl.textContent = Math.floor(score);
      bestEl.textContent = Math.max(best, Math.floor(score));
      speedEl.textContent = speed.toFixed(2);

      // move hazards (frame-rate independent)
      const k = dt / 16.6667; // normalize to 60fps
      obstacles.forEach(o => o.x -= speed * k);
      birds.forEach(b => { b.x -= speed * k; b.t += dt; });

      // cleanup off-screen
      obstacles = obstacles.filter(o => o.x + o.w > -40);
      birds = birds.filter(b => b.x + b.s > -40);

      // spawn
      maybeSpawnHazard(t);

      // collisions
      for (const o of obstacles) {
        // cactus rect
        const rx = o.x, ry = GROUND_Y - o.h, rw = o.w, rh = o.h;
        if (rectOverlap(dino.x, dino.y, dino.size, dino.size, rx, ry, rw, rh)) {
          handleDeath(); break;
        }
      }
      for (const b of birds) {
        if (rectOverlap(dino.x, dino.y, dino.size, dino.size, b.x, b.y, b.s, b.s)) {
          handleDeath(); break;
        }
      }

      // difficulty ramp (gentle)
      if (Math.floor(score) % 70 === 0) {
        speed = Math.min(9.5, speed + 0.01);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ground
      ctx.strokeStyle = '#cfd6e6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(canvas.width, GROUND_Y);
      ctx.stroke();

      // dashed road line
      ctx.strokeStyle = '#e9edf6';
      ctx.setLineDash([18, 10]);
      ctx.lineDashOffset -= 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 10);
      ctx.lineTo(canvas.width, GROUND_Y + 10);
      ctx.stroke();
      ctx.setLineDash([]);

      // cacti
      for (const o of obstacles) drawCactus(o.x, GROUND_Y - o.h, o.w, o.h);

      // birds
      for (const b of birds) drawBird(b);

      // dino
      dino.draw();
    }

    function drawCactus(x, y, w, h) {
      ctx.fillStyle = '#22c55e';
      roundRect(x, y, w, h, 6, true, false);
      // arms
      ctx.fillStyle = '#16a34a';
      ctx.fillRect(x + w*0.18, y + h*0.25, 4, 14);
      ctx.fillRect(x + w*0.72, y + h*0.5, 4, 16);
    }

    function drawBird(b) {
      // body
      ctx.fillStyle = '#3b82f6';
      roundRect(b.x, b.y + 6, b.s, b.s - 12, 8, true, false);
      // wing flap
      ctx.save();
      ctx.translate(b.x + b.s*0.4, b.y + b.s*0.3);
      ctx.rotate(Math.sin(b.t * 0.02) * 0.4);
      roundRect(-b.s*0.35, -6, b.s*0.7, 12, 6, true, false);
      ctx.restore();
      // eye
      ctx.fillStyle = '#0b0f1a';
      ctx.fillRect(b.x + b.s*0.7, b.y + b.s*0.28, 3, 3);
    }

    function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    // ===== Main loop =====
    function loop(now) {
      const dt = Math.min(48, now - lastTime);
      lastTime = now;
      update(dt, now);
      draw();
      requestAnimationFrame(loop);
    }

    // ===== Init =====
    bestEl.textContent = best;
    renderBoard();
    showOverlay('Tap or press Space to start', 'Spin like a GD cube. Avoid cacti and birds.');
    lastCactusTime = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>
</html>